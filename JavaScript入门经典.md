# JavaScript高级程序设计

## 第1章 什么是JavaScript

1、JavaScript已被公认为主流的编程语言，能够实现复杂的计算与交互，包括闭包、匿名（lambda）函数，甚至元编程等特性。

### 1.1 简单的历史回顾

## 第2章 HTML中的JavaScript

### 2.1 script元素

1、将JavaScript插入HTML的主要方法是使用`<script>`元素。

2、script元素有八个可选属性，async, charset, crossorigin, defer, intergrity, language, src, type。

3、在`<script>`元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。

4、要包含外部文件中的JavaScript，就必须使用src属性。这个属性的值是一个URL，指向包含JavaScript代码的文件。

使用了src属性的`<script>`元素不应该再在`<script>`和`</script>`标签中再包含其他JavaScript代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。

5、可以包含来自外部域的JavaScript文件。跟`<img>`元素很像，`<script>`元素的src属性可以是一个完整的URL，而且这个URL指向的资源可以跟包含它的HTML页面不在同一个域中。

浏览器在解析外部资源时，会向src属性指定的路径发送一个GET请求，以取得相应资源，假定是一个JavaScript文件。

在包含外部域的JavaScript文件时，要确保该域是自己所有的，或者该域是一个可信的来源。`<script>`标签的integrity属性是防范这种问题的一个武器，但这个属性也不是所有浏览器都支持。

**2.1.1 标签位置**

1、现代Web应用程序通常将所有JavaScript引用放在`<body>`元素中的页面内容后面。

这样一来，页面会在处理JavaScript代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。

**2.1.2 推迟执行脚本**

1、defer属性使脚本会被延迟到整个页面都解析完毕后再运行。

defer属性只对外部脚本文件才有效。

**2.1.3 异步执行脚本**

1、async属性和defer属性类似，但标记为async的脚本并不保证能按照它们出现的次序执行。

**2.1.4 动态加载脚本**

1、JavaScript可以使用DOM API，所以通过向DOM中动态添加script元素同样可以加载指定的脚本。只要创建一个script元素并将其添加到DOM即可。

2、默认情况下，以这种方式创建的`<script>`元素是以异步方式加载的，相当于添加了async属性。但可以设置属性为同步加载。

## 第3章 语言基础

### 3.1 语法

**3.1.1 区分大小写**

**3.1.2 标识符**

ECMAScript标识符使用驼峰大小写形式。

**3.1.3 注释**

和C一样。

**3.1.4 严格模式**

1、ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。添加'use strict'即可。

2、也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可。

**3.1.5 语句**

尽量使用括号和逗号。

## 第4章 变量、作用域和内存

### 4.1 原始值与引用值

1、原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。

2、六种原始值：Undefined、Null、Boolean、Number、String和Symbol。

3、JavaScript不允许直接访问内存位置，在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。

**4.1.1 动态属性**

1、原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。

2、对于引用值而言，可以随时添加、修改和删除其属性和方法。

3、原始值不能有属性，尽管尝试给原始值添加属性不会报错。

4、原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值。

**4.1.2 复制值**

和大多数语言一样，复制原始值时原始值被复制到新的位置，而复制引用值时复制的是一个指针。

## 第5章 基本引用类型

1、引用值（或者对象）是某个特定引用类型的实例。新对象通过使用new操作符后跟一个构造函数（constructor）来创建。

2、从技术上讲JavaScript是一门面向对象语言，但ECMAScript缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。

3、ECMAScript提供了很多像Date这样的原生引用类型，帮助开发者实现常见的任务。

4、函数也是一种引用类型。

### 5.1 Date

1、Date类型将日期保存为自协调世界时（UTC, Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。

2、要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX纪元1970年1月1日午夜之后的毫秒数）。

3、Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。

如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()。

4、Date.UTC()方法也返回日期的毫秒表示，但使用的是跟Date.parse()不同的信息来生成这个值。

与Date.parse()一样，Date.UTC()也会被Date构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是GMT日期。

5、ECMAScript还提供了Date.now()方法，返回表示方法执行时日期和时间的毫秒数。

**5.1.1 继承的方法**

1、与其他类型一样，Date类型重写了toLocaleString()、toString()和valueOf()方法。

toLocaleString()、toString()的输出已经接近一致。

2、Date类型的valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。

**5.1.2 日期格式化方法**

这些方法返回日期的不同字符串表示。

**5.1.3 日期/时间组件方法**

取得或设置日期值的特定部分。

## 第11章 期约与异步函数

### 11.1 异步编程

1、在JavaScript这种单线程事件循环模型中，同步操作与异步操作是代码所要依赖的核心机制。

2、异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。

3、异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。

**11.1.1 同步与异步**

1、同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。

2、异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。

3、异步代码不容易推断。执行异步操作会生成一个入队执行的中断。到底什么时候会触发这个中断，这对JavaScript运行时来说是一个黑盒，因此实际上无法预知。

**11.1.2 以往的异步编程模式**

1、在早期的JavaScript中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。

异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调。

2、随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。

### 11.2 期约

1、期约是对尚不存在结果的一个替身。

2、ECMAScript 6增加了Promise类型。一经推出，Promise就大受欢迎，成为了主导性的异步编程机制。

**11.2.1 Promises/A+规范**

1、所有现代浏览器都支持ES6期约，很多其他浏览器API（如fetch()和Battery Status API）也以期约为基础。

**11.2.2 期约基础**

1、ECMAScript 6新增的引用类型Promise，可以通过new操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数。

2、期约是一个有状态的对象，可能处于如下3种状态之一：待定，兑现，拒绝。

3、待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。

组织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该具有恰当的行为。

4、期约抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。

5、每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。

在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。

6、执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。

控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为resolve()和reject()。调用resolve()会把状态切换为兑现，调用reject()会把状态切换为拒绝。

7、通过调用Promise.resolve()静态方法，可以实例化一个解决的期约。使用这个静态方法，实际上可以把任何值都转换为一个期约。

对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()可以说是一个幂等方法。

8、Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过try/catch捕获，而只能通过拒绝处理程序捕获）。

9、拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。

**11.2.3 期约的实例方法**

1、期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

2、在ECMAScript暴露的异步结构中，任何对象都有一个then()方法。这个方法被认为实现了Thenable接口。

ECMAScript的Promise类型实现了Thenable接口。

3、Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个then()方法接收最多两个参数：onResolved处理程序和onRejected处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。

4、Promise.prototype.then()方法返回一个新的期约实例。

5、Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用Promise.prototype. then(null, onRejected)。

Promise.prototype.catch()返回一个新的期约实例。

10、Promise.prototype.finally()方法用于给期约添加onFinally处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免onResolved和onRejected处理程序中出现冗余代码。但onFinally处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。

11、当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。

12、如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。

13、在执行函数中，解决的值和拒绝的理由是分别作为resolve()和reject()的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为onResolved或onRejected处理程序的唯一参数。

**11.2.4 期约连锁与期约合成**

1、多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者就是一个期约接一个期约地拼接，后者则是将多个期约组合为一个期约。

2、把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法（then()、catch()和finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法调用就可以构成所谓的“期约连锁”。

3、因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样，每个期约都是图中的一个节点，而使用实例方法添加的处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序。

**11.2.5 期约扩展**

### 11.3 异步函数

1、异步函数，也称为“async/await”（语法关键字），是ES6期约模式在ECMAScript函数中的应用。

async/await是ES8规范新增的。这个特性从行为和语法上都增强了JavaScript，让以同步方式写的代码能够异步执行。

**11.3.1 异步函数**

1、async关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。

使用async关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。

2、异步函数如果使用return关键字返回了值（如果没有return则会返回undefined），这个值会被Promise.resolve()包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约。

3、异步函数的返回值期待（但实际上并不要求）一个实现thenable接口的对象，但常规的值也可以。如果返回的是实现thenable接口的对象，则这个对象可以由提供给then()的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。

4、因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用await关键字可以暂停异步函数代码的执行，等待期约解决。

5、await关键字会暂停执行异步函数后面的代码，让出JavaScript运行时的执行线程。这个行为与生成器函数中的yield关键字是一样的。await关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。

await关键字必须在异步函数中使用，不能在顶级上下文如`<script>`标签或模块中使用。

**11.3.2 停止与恢复执行**

1、async/await中真正起作用的是await。async关键字，无论从哪方面来看，都不过是一个标识符。毕竟，异步函数如果不包含await关键字，其执行基本上跟普通函数没有什么区别。

2、即使await后面跟着一个立即可用的值，函数的其余部分也会被异步求值。

**11.3.3 异步函数策略**

## 附录D JavaScript工具

### D.1 包管理

1、第三方库也称为“包”，托管在公开代码仓库中。

2、JavaScript包管理器可以管理项目依赖的包，涉及获取和安装，以及版本控制。

3、包管理器提供了命令行界面，用于安装和删除项目依赖。项目的配置通常存储在项目本地的配置文件中。

**D.1.1 npm**

1、npm，即Node包管理器（Node Package Manager），是Node.js运行时默认的包管理器。

2、在npm仓库中发布的第三方包可以指定为项目依赖，并通过命令行本地安装。

3、npm仓库包含服务端和客户端JavaScript库。

4、在安装包时，npm使用嵌套依赖树解析所有项目依赖，每个项目依赖都会安装自己的依赖。这意味着如果项目依赖三个包A、B和C，而这三个包又都依赖不同版本的D，则npm会安装包D的三个版本。

> 另外还有Bower和JSPM两个包管理器

**D.1.4 Yarn**

1、Yarn是Facebook开发的定制包管理器，从很多方面看是npm的升级版。

2、Yarn和npm的主要区别是提供了加速安装、包缓存、锁文件等功能，且提供了改进了包安全功能。

