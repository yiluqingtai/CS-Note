书籍地址：[前言 · Go语言圣经 (itsfun.top)](https://book.itsfun.top/gopl-zh/)

## 前言

### Go语言项目

1、Go语言拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。

2、Go语言没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。

3、Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。

4、Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。

5、Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。

### 本书的组织

1、第一章到第五章是基础部分，主流命令式编程语言这部分都类似。

个别之处，Go语言有自己特色的语法和风格，但是大多数程序员能很快适应。

其余章节是Go语言特有的：方法、接口、并发、包、测试和反射等语言特性。

2、Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。

方法不仅可以定义在结构体上，而且，可以定义在任何用户自定义的类型上；并且，具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。

3、其他资料

Go语言安装：[Download and install - The Go Programming Language (golang.org)](https://golang.org/doc/install)。（linux下流程：下载压缩包、解压、设置环境变量）

Go语言的官方博客 https://blog.golang.org 会不定期发布一些Go语言最好的实践文章，包括当前语言的发展状态、未来的计划、会议报告和Go语言相关的各种会议的主题等信息。

在线访问的一个有价值的地方是可以从web页面运行Go语言的程序（而纸质书则没有这么便利了）。这个功能由来自 https://play.golang.org 的 Go Playground 提供。

Go语言是一个开源项目，你可以在 https://golang.org/pkg 阅读标准库中任意函数和类型的实现代码，和下载安装包的代码完全一致。

### 更多的信息

## 1 入门

### 1.1 Hello,World

1、Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。

2、Go语言提供的工具都通过一个单独的命令go调用，go命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。

3、go build命令编译生成可执行文件。

4、go get命令从网上下载代码，需要提前设置好GOPATH变量。

5、go语言的helloworld

```go
package main

import 'fmt'

func main() {
    fmt.Println("hello, world!")
}
```

6、Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。

一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。

每个源文件都以一条package声明语句开始，helloworld的例子里就是package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。

Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如fmt包，就含有格式化输出、接收输入的函数。Println是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。

main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main 函数 也很特殊，它是整个程序执行时的入口。

必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。

7、包声明之后是组成程序的函数、变量、常量、类型的声明语句（分别由关键字func、var、const、type定义）。

8、Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。

9、gofmt工具把代码格式化为标准格式，需要养成格式化代码的好习惯。

### 1.2 命令行参数

1、os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。

2、os.Args变量是一个字符串（string）的切片（slice）。

3、os.Args的第一个元素：os.Args[0]，是命令本身的名字；其它的元素则是程序启动时传给它的参数。

4、echo例子：打印命令行参数。

5、变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的零值（zero value），数值类型是0，字符串类型是空字符串""。

6、对string类型，+运算符连接字符串。

7、Go语言只有for循环这一种循环语句。

for循环三个部分不需括号包围。大括号强制要求，左大括号必须和post语句在同一行。

initialization语句是可选的，在循环开始前执行。initalization如果存在，必须是一条简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。

for循环的这三个部分每个都可以省略，如果省略initialization和post，分号也可以省略。

8、另一种for循环

在某种数据类型的区间（range）上遍历，如字符串或切片。使用range关键词。

每次循环迭代，range产生一对值；索引以及在该索引处的元素值。

不需要索引，可以使用空标识符（blank identifier），即_（也就是下划线）。空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。

9、声明一个变量有好几种方式

```go
s := "" // 是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量
var s string // 依赖于字符串的默认初始化零值机制，被初始化为""
var s = "" // 用得很少，除非同时声明多个变量。
var s string = "" // 显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了
//实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。
```

### 1.3 查找重复的行

1、正如for循环一样，if语句条件两边也不加括号，但是主体部分需要加。if语句的else部分是可选的，在if的条件为false时执行。

2、内置函数make创建空map。例如：`make(map[string]int)`，键为字符串，值为int。

3、bufio包处理输入和输出方便又高效。Scanner类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。

4、类似于C或其它语言里的printf函数，fmt.Printf函数对一些表达式产生格式化输出。

5、Go读取文件：os.Open函数。os.Open函数返回两个值。第一个值是被打开的文件(*os.File），其后被Scanner读取。os.Open返回的第二个值是内置error类型的值。如果err等于内置值nil（译注：相当于其它语言里的NULL），那么文件被成功打开。

6、错误处理：使用Fprintf与表示任意类型默认格式值的动词%v，向标准错误流打印一条信息，然后dup继续处理下一个文件。

7、函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。

8、Go中的函数参数传递默认相当于C++中的引用传递。

9、ReadFile函数（来自于io/ioutil包），读取指定文件的全部内容。

10、strings.Split函数把字符串分割成子串的切片。

## 2 程序结构

### 2.1 命名

1、一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

2、有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。

3、名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。

4、在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。

## 3 基本数据类型

1、Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

2、基础类型包括：数字、字符串和布尔型。

3、复合数据类型包括数组和结构体——是通过组合简单类型，来表达更加复杂的数据结构。

4、引用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。

### 3.1 整型

1、Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。

2、两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint，不同的平台上会有不同的大小。

3、无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

4、Printf函数的%b参数打印二进制格式的数字；其中%08b中08表示打印至少8个字符宽度，不足的前缀部分用0填充。

5、即使数值本身不可能出现负数，我们还是倾向于使用有符号的int类型。无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。

6、对于每种类型T，如果转换允许的话，类型转换操作T(x)将x转换为T类型。

7、当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式

通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。

%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。

8、字符使用%c参数打印，或者是用%q参数打印带单引号的字符。

## 4 复合数据类型

1、复合数据类型：数组、slice、map和结构体。

2、数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。

3、slice和map则是动态的数据结构，根据需要动态增长。

### 4.1 数组

1、因为数组的长度是固定的，因此在Go语言中很少直接使用数组。

2、和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。

3、默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组。

4、在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。

5、可以指定一个索引和对应值列表的方式初始化

```go
r := [...]int{99: -1} // 定义了一个100个元素的数组，只有最后一个元素为-1，其他的为0
```

6、Printf函数的%x副词参数指定以十六进制的格式打印数组或slice全部的元素，%t副词参数是用于打印布尔型数据，%T副词参数是用于显示一个值对应的数据类型。

7、当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。

Go语言传入数组时一般显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。

### 4.2 Slice

1、Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。

2、一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。

3、一个slice由三个部分构成：指针、长度和容量。

指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。

长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。

内置的len和cap函数分别返回slice的长度和容量。

4、多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。

5、slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。

新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。

如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。

6、因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。

7、slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。

和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较。

slice唯一合法的比较操作是和nil比较。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的。

如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。

8、内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。

**4.2.1 append函数**

1、内置的append函数用于向slice追加元素。

2、append添加元素时，如果底层数组容量不够，将会重新创建一个容量翻倍的数组并进行复制，然后添加。

3、通常将append返回的结果直接赋值给输入的slice变量。

4、内置的append函数则可以追加多个元素，甚至追加一个slice。

**4.2.2 Slice内存技巧**

1、一个slice可以用来模拟一个stack。

最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack。

stack的顶部位置对应slice的最后一个元素。

通过收缩stack可以弹出栈顶的元素。

## 5 函数

### 5.1 函数声明

1、函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。

2、返回值列表描述了函数返回值的变量名以及类型。

3、如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。

_符号可以强调某个参数未被使用。

Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。

4、你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。

## 6 方法

1、Go语言使用方法来实现面向对象设计。

一个对象也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。

### 6.1 方法声明

1、在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。

附加的参数叫做方法的接收器，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。

建议使用类型的第一个字母作为接收器。

## 7 接口

### 7.1 接口是合约

1、接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。

2、接口类型使用type ${name} interface 的形式定义，接口中提供了起约束作用的函数签名。

3、fmt包的Printf和Sprintf函数都使用了Fprintf函数来封装，Fprintf的第一个参数类型是一个接口io.Writer，约定了Writer函数签名，`*os.File`和`*bytes.Buffer`都实现了Writer函数签名，所以可以传递给Fprintf函数。

## 8 Goroutines和Channels









