1、[递归算法的时间复杂度？ - 代码随想录的回答 - 知乎](https://www.zhihu.com/question/63075755/answer/1151037825)

递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归中的操作次数

分析了计算x的n次方的递归解法的时间复杂度，从o(n)降到o(logn)

2、[递归算法的时间复杂度？ - 知乎](https://www.zhihu.com/question/63075755/answer/1027121343)

这张表格很有参考价值

3、[递归算法时间复杂度分析_AcceptedLin的博客-CSDN博客_递归的时间复杂度怎么算](https://blog.csdn.net/u013185349/article/details/82744323)

一般情况下，算法中基本操作重复的次数就是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。

算法的空间复杂度并不是实际占用的空间，而是计算整个算法空间辅助空间单元的个数，与问题的规模没有关系。

递归算法空间复杂度：递归深度n*每次递归所要的辅助空间，如果每次递归所需要的辅助空间为常数，则递归空间复杂度o(n)。

4、[算法导论------递归算法的时间复杂度求解_麦田里的码农-CSDN博客_求递归关系式分析分治算法的时间复杂度](https://blog.csdn.net/so_geili/article/details/53444816)

非递归算法时间复杂度分析较为简单，通常是计算算法中基本语句执行次数，一般都是一个关于问题规模n的表达式，然后用渐近符号Θ、O、o、Ω、ωΘ、Ο、o、Ω、ω表示出算法的时间复杂度。

递归算法是采用分治的方法，把一个“大问题”分解出若干个相似的“小问题”求解。在分析算法复杂度时，关键是根据递归过程建立递推关系式，然后求解递推关系式，得到算法执行的时间表达式（一般都与问题规模n相关），最后用渐近符号Θ、O、o、Ω、ωΘ、Ο、o、Ω、ω表示出算法的时间复杂度。

如果算法的执行时间不随着问题规模n的增加而增长，它的基本语句执行的次数是固定的，总的时间由一个常数来限界。此类算法的时间复杂度是O(1)。

当有若干个循环语句时，时间复杂度是由嵌套层数最多的循环语句中的基本语句的执行次数决定。

虽然非递归算法的时间复杂度比较好分析，但往往需要用到多项式的求和技巧和放缩技巧。

递归算法的分析方法：数列知识、代入法、递归树、主方法求解递推式

> 综合分析，还是递归树法求时间复杂度最实用，将各层的代价加起来。